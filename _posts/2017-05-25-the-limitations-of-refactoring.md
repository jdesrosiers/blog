---
layout: post
title:  "The Limitations of Refactoring"
date:   2017-05-25 17:00:00
tags: [refactoring, http-server]
---

I recently started reading Martin Fowler’s book, “Refactoring”.  Early on, he acknowledges that the concept of refactoring is new and not a lot is known about its limitations.  Even though the book was originally published in 1999, I’m not sure that today we have much more to say about the limitations of refactoring.  It’s all still very speculative and anecdotal as far as I know.

Lately I have been writing an HTTP server in Java.  When I started, I had a pretty good idea of the features and high level interface I wanted to have, but I had no idea how I was going to implement most of it.  So, my HTTP server implementation ended up being a pretty typical example of evolutionary design.  I did a lot of refactoring along the way, so I thought it might be an interesting case study for this concept of the limitations of refactoring.

For the most part I was able to refactor pretty freely.  There are two practices that I credit for having easily refactorable code.  The first practice is to keep coupling low.  This is sometimes known as the dependency elimination principle.  The better you can isolate the modules of the system the easier it is to change them.  The second thing I did has to do with tests.  One reason some developers are hesitant to refactor (or hesitant to write tests) is because when you refactor, it often breaks your tests.  You then need to rewrite your tests or throw them out.  When I develop a behavior that I know is likely to evolve, I will focus on writing tests at a higher level.  That gives me more freedom to move things around and change things without breaking tests.  I still had to move tests around a little or make changes here and there, but it was always minor enough that I was never tempted not to do it because the job was too onerous.

There was one thing, about halfway through I decided I wanted to change, but never did because it would be too disruptive.  I have classes for describing HTTP request and response messages.  These are typical Java classes that hold state and have getters and setters to change that state.  I noticed that these classes are getting passed around from module to module and some of those modules modify the state.  It is often not clear if or when the value has changed.  So, I decided that it would be better if my Request and Response classes were immutable.

But, this is not an easy thing to change.  It can be done if it was causing enough pain, but it would be a complicated process.  The reason it is hard to change is that all of the modules have a dependency on the Request and Response classes.  Changing those classes can have effects throughout the entire system.  It’s not a change that can be automated.  For example, return statements might need to be added and variables introduced to catch those return values.

So, the question is, could I have avoided this difficulty somehow?  The practices I identified above help me write code that is easier to refactor, but is there a practice I am missing that could have helped make this situation easier?  In this case, immutability is the goal, but it could also be the principle I was missing.  The reason refactoring was hard in this case is because of side effects.  Having to add return values and catch those values is the main problem.  It seems that another principle I can use to write code that is easily refactored is to prefer immutable structures. It’s hard to see with this example, but I believe that mutation in general makes it difficult to automate some refactorings.  I usually prefer immutable structures, but I since I am writing Java code I decided to write it in the typical Java way.  I would do it differently the next time.

In the end, I don’t think we really know anything more about the limitations of refactoring than they knew back in 1999.  What we know is largely anecdotal just like this case study.  Refactoring certainly can get difficult at times, but I think we can make things easier on ourselves by having some good practices.  The nice thing is that those practices line up with good coding practices in general.  Unfortunately, it seems that in order to be able to refactor quickly and efficiently, you need to start with good code.  Some practices have diminishing returns.  You get more out of them when you start, but after a while the benefits level off.  I think refactoring is the opposite.  Starting to refactor code that is in really bad shape can be slow and painful to make small improvements.  But, as your code gets cleaner, you can refactor more often and more quickly.  Refactoring has increasing returns, which is a pretty valuable property in any industry.
